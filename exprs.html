<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Test expressions - Club des Expressions</title>
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            extensions: ["tex2jax.js","fp.js"],
            MathMenu: {
                showLocale: false,
            },
            jax: ["input/TeX","output/HTML-CSS"],
            tex2jax: {
                inlineMath: [['$','$']],
                displayMath: [['$$','$$']],
                }
            });
        </script>
        <script type="text/javascript" src="mathjax/MathJax.js?locale=fr"></script>
    </head>
    <body>
        <noscript>
            <div style="color:#CC0000; text-align:center">
            Besoin de JavaScript pour afficher la page.
            </div>
        </noscript>
        <h1>Liste des expressions officielles du Club</h1>
        <script>

function contains(arr, obj) {return arr.indexOf(obj) !== -1;}

// For convenience, definitions are done with variables.
var a = 'c1';
var b = 'c2';
var c = 'c3';
var d = 'c4';
var x = 'x';
var y = 'y';
// Opérations:
var S  = 'Somme';
var D  = 'Diff';
var P  = 'Produit';
var Q  = 'Quotient';
var O  = 'Opposé';
var I  = 'Inverse';
var C  = 'Carré';
var Pu = 'Puissance';
var R  = 'Racine';
// Les calculs entre parenthèses sont prioritaires.
var Pa = 'parenthèses';
// Dans une expression sans parenthèses avec uniquement des additions et des
// soustractions, on effectue les calculs de gauche à droite.
var GD = 'gauche-droite';
// Dans une expression sans parenthèses, les multiplications et les divisions
// ont priorité sur les additions, les soustractions et les passages à l'opposé.
var MD = 'mult-div';
// Dans une expression sans parenthèses, l'élévation à une puissance a priorité
// sur les quatre opérations usuelles et sur le passage à l'opposé.
var El = 'élévation';
// Dans une expression sans parenthèses, le passage à l'opposé a priorité sur
// l'addition et la soustraction.
var Op = 'opposé';
// Devant une lettre ou une parenthèse, le signe « × » de la multiplication est
// facultatif.
var X = 'signeX';
// Lorsque la division est indiquée par un trait de fraction, les parenthèses
// autour des expressions au numérateur et au dénominateur sont facultatives.
var F = 'fraction';

// Callback for rendering each expression
function processExpr(cexpr, idx) {
    var link = '<a href="#e' + (idx+1) + '">' + (idx+1) + '.</a>';
    document.write('<h2 id="e' + (idx+1) + '">' + link + ' ' + cexpr.nom + '</h2>');
    document.write(renderExprAsLisp(cexpr));
    document.write("$$" + renderExprAsLaTeX(cexpr) + "$$");
    if (cexpr.conv.length) {
        document.write("  conventions : ");
        document.write(cexpr.conv.join(', '));
    }
    document.write("<br>");
}

function prepareArgs(cexpr) {
    var args = cexpr.expr.slice(1);
    // Attach coeffs and parent command to args
    var cargs = args.map(function(arg) {
        return {"expr": arg,
                "parent": cexpr.expr[0],
                "coeffs": cexpr.coeffs};
    });
    return cargs;
}

function renderExprAsLisp(cexpr) {
    if (typeof cexpr.expr === 'object') {
        var cmd = cexpr.expr[0];
        var args = prepareArgs(cexpr).map(renderExprAsLisp);
        return '(' + cmd + ' ' + args.join(' ') + ')';
    } else {
        return leaf(cexpr);
    }
}

function parens(cmd, parent_cmd) {
    if (contains([S,D], cmd)) {
        return contains([P], parent_cmd);
    }
    return false;
}

function renderExprAsLaTeX(cexpr) {
    if (typeof cexpr.expr === 'object') {
        var cmd = cexpr.expr[0];
        var args = prepareArgs(cexpr).map(renderExprAsLaTeX);
        var latex = '';
        if (cmd === 'Somme'    ) latex = args.join('+');
        if (cmd === 'Diff'     ) latex = args[0] + "-" + args[1]
        if (cmd === 'Produit'  ) latex = args.join('×');
        if (cmd === 'Quotient' ) latex = "\\frac{" + args[0] + "}{" + args[1] + "}"
        if (cmd === 'Opposé'   ) latex = "-\\left(" + args[0] + "\\right)"
        if (cmd === 'Inverse'  ) latex = "\\frac{1}{" + args[0] + "}"
        if (cmd === 'Carré'    ) latex = "\\left(" + args[0] + "\\right)^2"
        if (cmd === 'Puissance') latex = "\\left(" + args[0] + "\\right)^" + args[1]
        if (cmd === 'Racine'   ) latex = "\\sqrt{" + args[0] + "}"
        if (latex === '') return "Unknown cmd: " + cmd;
        if (parens(cmd, cexpr.parent)) latex = '\\left(' + latex + '\\right)';
        return latex;
    } else {
        return leaf(cexpr);
    }
}

function leaf(cexpr) {
    if (cexpr.expr[0] === 'c') {
        var coeffIndex = parseInt(cexpr.expr[1])-1;
        return cexpr.coeffs[coeffIndex];
    } else {
        return cexpr.expr;
    }
}

// The expressions (from the boss himself)
var exprs = [
{"nom" : "Somme",
 "conv": [],
 "expr": [S,x,y]},
{"nom" : "Différence",
 "conv": [],
 "expr": [D,x,y]},
{"nom" : "Multiple",
 "conv": [],
 "expr": [P,a,x]},
{"nom" : "Division par un entier",
 "conv": [],
 "expr": [Q,x,a]},
{"nom" : "Carré",
 "conv": [],
 "expr": [C,x]},
{"nom" : "Puissance 4",
 "conv": [],
 "expr": [Pu,x,4]},
{"nom" : "Inverse",
 "conv": [],
 "expr": [I,x]},
{"nom" : "Opposé",
 "conv": [],
 "expr": [O,x]},
{"nom" : "Homographique séparée",
 "conv": [F,MD],
 "expr": [S,a,[Q,b,[S,[P,c,x],d]]]},
];

// Build a random coefficients array (first integers shuffled)
function coeffs() {
    var ints = [2, 3, 4, 5, 6, 7, 8, 9];
    var counter = ints.length;
    while (counter > 0) {
        var index = Math.floor(Math.random() * counter);
        counter--;
        // swap
        let temp = ints[counter];
        ints[counter] = ints[index];
        ints[index] = temp;
    }
    return ints;
}

var cexprs = exprs.map(function (expr) {
    return {"nom" : expr.nom,
            "conv": expr.conv,
            "expr": expr.expr,
            "coeffs": coeffs()};
});
// Iterate through expressions
cexprs.forEach(processExpr);

        </script>
    </body>
</html>
