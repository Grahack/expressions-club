<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Test expressions - Club des Expressions</title>
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            extensions: ["tex2jax.js","fp.js"],
            MathMenu: {
                showLocale: false,
            },
            jax: ["input/TeX","output/HTML-CSS"],
            tex2jax: {
                inlineMath: [['$','$']],
                displayMath: [['$$','$$']],
                }
            });
        </script>
        <script type="text/javascript" src="mathjax/MathJax.js?locale=fr"></script>
    </head>
    <body>
        <noscript>
            <div style="color:#CC0000; text-align:center">
            Besoin de JavaScript pour afficher la page.
            </div>
        </noscript>
        <h1>Liste des expressions officielles du Club</h1>
        <script>

function belongsTo(obj, arr) {return arr.indexOf(obj) !== -1;}

// For convenience, definitions are done with variables.
var a = 'c1';
var b = 'c2';
var c = 'c3';
var d = 'c4';
var e = 'c5';
var f = 'c6';
var g = 'c7';
var h = 'c8';
var x = 'x';
var y = 'y';
// Opérations:
var S  = 'Somme';
var D  = 'Diff';
var P  = 'Produit';
var Q  = 'Quotient';
var O  = 'Opposé';
var I  = 'Inverse';
var C  = 'Carré';
var Pu = 'Puissance';
var R  = 'Racine';
// Les calculs entre parenthèses sont prioritaires.
var Pa = 'parenthèses';
// Dans une expression sans parenthèses avec uniquement des additions et des
// soustractions, on effectue les calculs de gauche à droite.
var GD = 'gauche-droite';
// Dans une expression sans parenthèses, les multiplications et les divisions
// ont priorité sur les additions, les soustractions et les passages à l'opposé.
var MD = 'mult-div';
// Dans une expression sans parenthèses, l'élévation à une puissance a priorité
// sur les quatre opérations usuelles et sur le passage à l'opposé.
var El = 'élévation';
// Dans une expression sans parenthèses, le passage à l'opposé a priorité sur
// l'addition et la soustraction.
var Op = 'opposé';
// Devant une lettre ou une parenthèse, le signe « × » de la multiplication est
// facultatif.
var X = 'signe ×';
// Lorsque la division est indiquée par un trait de fraction, les parenthèses
// autour des expressions au numérateur et au dénominateur sont facultatives.
var F = 'fraction';

// Callback for rendering each expression
function processExpr(cexpr, idx) {
    var link = '<a href="#e' + (idx+1) + '">' + (idx+1) + '.</a>';
    document.write('<h2 id="e' + (idx+1) + '">' + link + ' ' + cexpr.nom + '</h2>');
    document.write(renderExprAsLisp(cexpr));
    document.write("$$" + renderExprAsLaTeX(cexpr) + "$$");
    if (cexpr.conv.length) {
        document.write("  conventions : ");
        document.write(cexpr.conv.join(', '));
    }
    // utility for writing tests
    // document.write("['" + renderExprAsLisp(cexpr) + "', '" +
    //                       renderExprAsLaTeX(cexpr) + "'],<br>");
}

function prepareArgs(cexpr) {
    var args = cexpr.expr.slice(1);
    // Attach coeffs and parent command to args
    var cargs = args.map(function(arg) {
        return {"expr": arg,
                "parent": cexpr.expr[0],
                "coeffs": cexpr.coeffs};
    });
    return cargs;
}

function renderExprAsLisp(cexpr) {
    if (typeof cexpr.expr === 'object') {
        var cmd = cexpr.expr[0];
        var args = prepareArgs(cexpr).map(renderExprAsLisp);
        return '(' + cmd + ' ' + args.join(' ') + ')';
    } else {
        return leaf(cexpr);
    }
}

function parens(cmd, parent_cmd) {
    if (belongsTo(cmd, [S,D])) {
        return belongsTo(parent_cmd, [D,P,O,C,Pu,R]);
    }
    if (belongsTo(cmd, [P,Q,O,I])) {
        return belongsTo(parent_cmd, [C,Pu]);
    }
    return false;
}

function renderExprAsLaTeX(cexpr) {
    if (typeof cexpr.expr === 'object') {
        var cmd = cexpr.expr[0];
        var args = prepareArgs(cexpr).map(renderExprAsLaTeX);
        var latex = '';
        if (cmd === 'Somme'    ) latex = args.join('+');
        if (cmd === 'Diff'     ) latex = args[0] + "-" + args[1];
        if (cmd === 'Produit'  ) {
            var lastArg = args[0];
            latex = args[0];
            for (var i = 1; i < args.length; i++) {
                var arg = args[i];
                if (!isNaN(parseInt(lastArg)) && isNaN(parseInt(arg)))
                    latex = latex + arg;
                else
                    latex = latex + '×' + arg;
                lastArg = arg;
            }
        }
        if (cmd === 'Quotient' ) latex = "\\frac{" + args[0] + "}{" + args[1] + "}";
        if (cmd === 'Opposé'   ) latex = "-" + args[0];
        if (cmd === 'Inverse'  ) latex = "\\frac{1}{" + args[0] + "}";
        if (cmd === 'Carré'    ) latex = args[0] + "^2";
        if (cmd === 'Puissance') latex = args[0] + "^" + args[1];
        if (cmd === 'Racine'   ) latex = "\\sqrt{" + args[0] + "}";
        if (latex === '') return "Unknown cmd: " + cmd;
        if (parens(cmd, cexpr.parent)) latex = '\\left(' + latex + '\\right)';
        return latex;
    } else {
        return leaf(cexpr);
    }
}

function leaf(cexpr) {
    if (cexpr.expr[0] === 'c') {
        var coeffIndex = parseInt(cexpr.expr[1])-1;
        return cexpr.coeffs[coeffIndex];
    } else {
        return cexpr.expr;
    }
}

// The expressions (from the boss himself)
var exprs = [
{"nom" : "Somme",
 "conv": [],
 "expr": [S,x,y]},
{"nom" : "Différence",
 "conv": [],
 "expr": [D,x,y]},
{"nom" : "Multiple",
 "conv": [],
 "expr": [P,a,x]},
{"nom" : "Division par un entier",
 "conv": [],
 "expr": [Q,x,a]},
{"nom" : "Carré",
 "conv": [],
 "expr": [C,x]},
{"nom" : "Puissance 4",
 "conv": [],
 "expr": [Pu,x,4]},
{"nom" : "Inverse",
 "conv": [],
 "expr": [I,x]},
{"nom" : "Opposé",
 "conv": [],
 "expr": [O,x]},
{"nom" : "Produit d’un coeff avec une somme",
 "conv": [P],
 "expr": [P,a,[S,x,b]]},
{"nom" : "Somme d’un coeff avec un produit",
 "conv": [MD,X],
 "expr": [S,a,[P,b,x]]},
{"nom" : "Différence entre produit et coeff",
 "conv": [MD,X],
 "expr": [D,[P,a,x],b]},
{"nom" : "Somme d’un coeff avec un quotient",
 "conv": [MD],
 "expr": [S,a,[Q,x,b]]},
{"nom" : "Différence entre un opposé et un coeff",
 "conv": [O],
 "expr": [D,[O,x],a]},
{"nom" : "Opposé d’une différence",
 "conv": [P],
 "expr": [O,[D,x,a]]},
{"nom" : "Différence entre un coeff et une somme",
 "conv": [P],
 "expr": [D,a,[S,a,x]]},
{"nom" : "Somme d’une différence avec un coeff",
 "conv": [GD],
 "expr": [S,[D,x,a],b]},
{"nom" : "Homographique séparée",
 "conv": [F,MD],
 "expr": [S,a,[Q,b,[S,[P,c,x],d]]]},
];

// Build a random coefficients array (first integers shuffled)
function coeffs() {
    var ints = [2, 3, 4, 5, 6, 7, 8, 9];
    var counter = ints.length;
    while (counter > 0) {
        var index = Math.floor(Math.random() * counter);
        counter--;
        // swap
        var temp = ints[counter];
        ints[counter] = ints[index];
        ints[index] = temp;
    }
    return ints;
}

var cexprs = exprs.map(function (expr) {
    return {"nom" : expr.nom,
            "conv": expr.conv,
            "expr": expr.expr,
            "coeffs": coeffs()};
});
// Iterate through expressions
cexprs.forEach(processExpr);

// Tests

// First, a little Lisp parser
// adapted from https://www.recurse.com/blog/21-little-lisp-interpreter
// I just added «input.» and skipped categorize

var tokenize = function(input) {
  return input.replace(/\(/g, ' ( ')
        .replace(/\)/g, ' ) ')
        .trim()
        .split(/\s+/);
};

var parenthesize = function(input, list) {
  if (list === undefined) {
    return parenthesize(input, []);
  } else {
    var token = input.shift();
    if (token === undefined) {
      return list.pop();
    } else if (token === "(") {
      list.push(parenthesize(input, []));
      return parenthesize(input, list);
    } else if (token === ")") {
      return list;
    } else {
      return parenthesize(input, list.concat(token));
    }
  }
};

var parse = function(input) {
  return parenthesize(tokenize(input));
};

var tests = [
['(Somme 1 1)', '1+1'],
['(Somme x y)', 'x+y'],
['(Diff x y)', 'x-y'],
['(Produit 2 2)', '2×2'],
['(Produit 2 x)', '2x'],
['(Produit x 2)', 'x×2'],
['(Produit x x)', 'x×x'],
['(Produit 6 x)', '6x'],
['(Quotient x 2)', '\\frac{x}{2}'],
['(Carré x)', 'x^2'],
['(Puissance x 4)', 'x^4'],
['(Inverse x)', '\\frac{1}{x}'],
['(Opposé x)', '-x'],
['(Produit 4 (Somme x 9))', '4\\left(x+9\\right)'],
['(Somme 8 (Produit 7 x))', '8+7x'],
['(Diff (Produit 8 x) 7)', '8x-7'],
['(Somme 2 (Quotient x 9))', '2+\\frac{x}{9}'],
['(Diff (Opposé x) 4)', '-x-4'],
['(Opposé (Diff x 9))', '-\\left(x-9\\right)'],
['(Diff 5 (Somme 5 x))', '5-\\left(5+x\\right)'],
['(Somme (Diff x 3) 7)', 'x-3+7'],
['(Somme 7 (Quotient 8 (Somme (Produit 3 x) 4)))', '7+\\frac{8}{3x+4}'],
['0', '0']
];
tests.map(function (test) {
    var codeClubIn = test[0];
    var cexpr = {"expr": parse(codeClubIn)};
    // The venerable round trip
    var codeClubOut = renderExprAsLisp(cexpr);
    if (codeClubOut !== codeClubIn) throw codeClubOut + ' != ' + codeClubIn;
    // LaTex test
    var expected = test[1];
    var rendered = renderExprAsLaTeX(cexpr);
    if (rendered !== expected) throw rendered + ' != ' + expected;
});
console.log("OK");

        </script>
    </body>
</html>
