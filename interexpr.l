(setq a "a" A "A" b "b" B "B" c "c" C "C" d "d" D "D" e "e" E "E")
(setq f "f" F "F" g "g" G "G" h "h" H "H" i "i" I "I" j "j" J "J")
(setq k "k" K "K" l "l" L "L" m "m" M "M" n "n" N "N" o "o" O "O")
(setq p "p" P "P" q "q" Q "Q" r "r" R "R" s "s" S "S" t "t")' # T protected
(setq u "u" U "U" v "v" V "V" w "w" W "W" x "x" X "X" y "y" Y "Y" z "z" Z "Z")

(de ma-def arg-list
    (let (
          nom (car arg-list)
          args (cadr arg-list)
          body (caddr arg-list)
         )
         (println nom)
         (println args)
         (println body)
         (println " ")
         (push 'liste-cmds nom)
         (def nom args body)
    )
    (def (car arg-list) (eval (cadr arg-list)) (eval (caddr arg-list)))
)
(setq cmds_list '(p somme diff oppose produitx produit produit. quotient inverse carre racine2 racine cube puissance indice imagepar cos sin))

(de opglue @
  (let (args (rest)
        op (car args)
        termes (cadr args)
        nbre_termes (length termes))
       (cond
         ((= nbre_termes 0) op)
         ((= nbre_termes 1) (pack (car termes) op))
         (T (glue op termes))
       )
  )
)
(de p (x) (pack "\\left( " x " \\right)"))
(de somme @ (opglue "+" (rest)))
(de diff (x y) (pack x " - " y))
(de oppose (x) (pack "-" x))
(de produitx @ (opglue " \\times " (rest)))
(de produit @ (opglue " " (rest)))
(de produit. @ (opglue " \\cdot " (rest)))
(de quotient (n d) (pack "\\frac{" n "}{" d "}"))
(de inverse (x) (pack "\\frac{" 1 "}{" x "}"))
(de carre (x) (pack "{" x "}\^2"))
(de racine2 (x) (pack "\\sqrt{" x "}"))
(de racine (n x) (pack "\\sqrt\[" n "\]{" x "}"))
(de cube (x) (pack "{" x "}\^3"))
(de puissance (x y) (pack "{" x "}\^{" y "}"))
(de indice (x y) (pack "{" x "}_{" y "}"))
(de imagepar (f x) (pack f " " (p x)))
(de cos (x) (pack "\\cos" (p x)))
(de sin (x) (pack "\\sin" (p x)))
