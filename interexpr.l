(setq a "a" A "A" b "b" B "B" c "c" C "C" d "d" D "D" e "e" E "E")
(setq f "f" F "F" g "g" G "G" h "h" H "H" i "i" I "I" j "j" J "J")
(setq k "k" K "K" l "l" L "L" m "m" M "M" n "n" N "N" o "o" O "O")
(setq p "p" P "P" q "q" Q "Q" r "r" R "R" s "s" S "S" t "t")' # T protected
(setq u "u" U "U" v "v" V "V" w "w" W "W" x "x" X "X" y "y" Y "Y" z "z" Z "Z")
(setq pi "\\pi" Pi "\\Pi")

(de ma-def arg-list
    (let (
          nom (car arg-list)
          args (cadr arg-list)
          body (caddr arg-list)
         )
         (println nom)
         (println args)
         (println body)
         (println " ")
         (push 'liste-cmds nom)
         (def nom args body)
    )
    (def (car arg-list) (eval (cadr arg-list)) (eval (caddr arg-list)))
)
(setq cmds_list '(somme diff oppose produitx produit produit. quotient inverse carre racine2 racine cube puissance terme_indice image_par cos sin ln exp par))

(put 'precedence 'somme     12)
(put 'precedence 'diff      13)
(put 'precedence 'oppose    14)
(put 'precedence 'produit   20)
(put 'precedence 'produit.  21)
(put 'precedence 'produitx  22)
(put 'precedence 'exp       25)
(put 'precedence 'ln        25)
(put 'precedence 'carre     30)
(put 'precedence 'puissance 30)
(put 'precedence 'cube      30)
(put 'precedence 'racine2  NIL)
(put 'precedence 'racine   NIL)
(put 'precedence 'inverse  NIL)
(put 'precedence 'quotient NIL)
(put 'precedence 'image_par NIL)
(put 'precedence 'cos      NIL)
(put 'precedence 'sin      NIL)
(put 'precedence 'terme_indice   NIL)

(de add_p prg
  (glue "\\text{ ? }" (mapcar 'add_p_rec prg)))

(de add_p_rec (prg parent_precedence)
  (if (atom prg)
      (eval prg)
      (let (op (car prg)
            terms (cdr prg)
            current_precedence (get 'precedence op))
           (let (children_with_p
                  (mapcar '((term) (add_p_rec term current_precedence))
                          terms))
                (if (and current_precedence
                         parent_precedence
                         (>= parent_precedence current_precedence))
                    (par (apply op children_with_p))
                    (apply op children_with_p)
                )
           )
      )
  )
)
(de opglue @
  (let (args (rest)
        op (car args)
        termes (cadr args)
        nbre_termes (length termes))
       (cond
         ((= nbre_termes 0) (pack "?" op "?"))
         ((= nbre_termes 1) (pack (car termes) op "?"))
         (T (glue op termes))
       )
  )
)
(de ? (x) (if x @ "?"))

(de par (x) (pack "\\left( " (? x) " \\right)"))
(de somme @ (opglue "+" (rest)))
(de diff (x y) (pack (? x) " - " (? y)))
(de oppose (x) (pack "-" (? x)))
(de produitx @ (opglue " \\times " (rest)))
(de produit @ (opglue " " (rest)))
(de produit. @ (opglue " \\cdot " (rest)))
(de quotient (n d) (pack "\\frac{" (? n) "}{" (? d) "}"))
(de inverse (x) (pack "\\frac{" 1 "}{" (? x) "}"))
(de carre (x) (pack "{" (? x) "}\^2"))
(de racine2 (x) (pack "\\sqrt{" (? x) "}"))
(de racine (n x) (pack "\\sqrt\[" (? n) "\]{" (? x) "}"))
(de cube (x) (pack "{" (? x) "}\^3"))
(de puissance (x y) (pack "{" (? x) "}\^{" (? y) "}"))
(de terme_indice (x y) (pack "{" (? y) "}_{" (? x) "}"))
(de image_par (f x) (pack (? f) "  \\left( " (? x) " \\right)"))  # spaces for distinction with produit
(de cos (x) (pack "\\cos" (par (? x))))
(de sin (x) (pack "\\sin" (par (? x))))
(de exp (x) (pack "\\exp" (? x)))
(de ln (x)  (pack "\\ln"  (? x)))
