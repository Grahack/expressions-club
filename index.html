<!DOCTYPE html>
<html>
<!-- Thx to http://reactfordesigners.com/labs/reactjs-introduction-for-people-who-know-just-enough-jquery-to-get-by/ -->
<head>
  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="jquery.min.js"><\/script>')</script>
  <script src="react/react.min.js"></script>
  <script src="react/JSXTransformer.js"></script>
  <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet" type="text/css" />
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      extensions: ["tex2jax.js","fp.js"],
      MathMenu: {
          showLocale: false,
      },
      jax: ["input/TeX","output/HTML-CSS"],
      tex2jax: {
          inlineMath: [['$','$']],
          displayMath: [['$$','$$']],
          }
      });
  </script>
  <script type="text/javascript" src="mathjax/MathJax.js?locale=fr"></script>
  <script type="text/javascript" src="mathjax-preview/mathjax-preview.js"></script>
  <link href="mathjax-preview/mathjax-preview.css" rel="stylesheet" type="text/css" />
  <script src="int.js" type="text/javascript"></script>
  <script src="emulisp_core.js" type="text/javascript"></script>
  <link href="style.css" rel="stylesheet" type="text/css" />
  <script src="parenedit/parenedit.js" type="text/javascript"></script>
  <link type="text/css" href="parenedit/parenedit.css" rel="stylesheet" />
  <meta charset="utf-8">
  <title>Expressions interactives</title>
</head>
<body>
  <div class="well clearfix">
    <div id="jsx">Ça charge… Si les symptômes persistent, c’est que vous n’avez peut-être pas activé JavaScript.</div>
    <div id="doc">
      <p>Voici la liste des commandes utilisables (<code>p</code> pour
         parenthèses, n’accepte qu’un argument) : <br />
         <span id="cmds-list"></span>.</p>
      <p><strong>Exemples</strong> :</p>
      <ul>
        <li>pour $2+2$, il faut taper <code>(somme 2 2)</code> ;</li>
        <li>pour $2x+1$, il faut taper <code>(somme (produit 2 x) 1)</code> ;</li>
        <li>pour $2×\left(x+1\right)$, il faut taper <code>(produit 2 (p (somme x 1)))</code>.</li>
      </ul>
      <p><strong>Abréviations</strong> :</p>
      <p>Ctrl+B déclenche l’expansion d’une abréviation :</p>
      <ul>
        <li>(s -> (somme |)</li>
        <li>(d -> (diff |)</li>
        <li>(o -> (oppose |)</li>
        <li>(p -> (produit |)</li>
        <li>(p. -> (produit. |)</li>
        <li>(q -> (quotient |)</li>
        <li>(i -> (inverse |)</li>
        <li>(ca -> (carre |)</li>
        <li>(r2 -> (racine2 |)</li>
        <li>(r -> (racine |)</li>
        <li>(ca -> (cube |)</li>
        <li>(pu -> (puissance |)</li>
        <li>(in -> (indice |)</li>
        <li>(im -> (imagepar |)</li>
      </ul>
    </div>
  </div>
  <script>
    // http://www.sitepoint.com/jquery-set-focus-character-range/
    $.fn.selectRange = function(start, end) {
        return this.each(function() {
            if (this.setSelectionRange) {
                this.focus();
                this.setSelectionRange(start, end);
            } else if (this.createTextRange) {
                var range = this.createTextRange();
                range.collapse(true);
                range.moveEnd('character', end);
                range.moveStart('character', start);
                range.select();
            }
        });
    };
    EMULISP_CORE.loadLisp("picolisp.l");
    EMULISP_CORE.loadLisp("interexpr.l");
  </script>
  <script type="text/jsx">
  var url = window.location.toString();
  var series_id = url.substring(url.indexOf('?') + 1);
  // Only allow alphanum chars, - and _ and non empty strings.
  if (!series_id.match(/^[a-z0-9-_]+$/i)) {
      series_id = 'default';
  }
  var InterExpr = React.createClass({
    getInitialState: function() {
      return {
        series_id: series_id,
        running: true,
        rapport: false,
        text: "",
        score: undefined,
        series: false,
        expr_id: 0
      };
    },
    inSeriesGet: function(what) {
      if (!this.state.series) return "???";
      if (what == 'point_duration')
        return this.state.series.config.point_duration;
      if (what == 'points')
        return this.state.series.exprs[this.state.expr_id].points;
      if (what == 'expr') {
        if (this.state.running) {
          return this.state.series.exprs[this.state.expr_id].expr;
        } else {
          return '';
        }
      }
    },
    componentDidMount: function() {
      $.get('series/' + series_id + '.json', function(result) {
        if (this.isMounted()) {
          this.setState({
              series: result,
              score: result.config.initial_score
              });
          this.timer = setInterval(this.tick,
                                   this.state.series.config.point_duration * 1000);
          this.state.series.exprs[0].date_start = Date.now();
          this.state.series.exprs[0].score_start = this.state.score;
        }
      }.bind(this));
    },
    componentDidUpdate: function (props, state, root) {
      var elt = document.getElementById('target');
      MathJax.Hub.Queue(['Typeset', MathJax.Hub, elt]);
    },
    componentWillUnmount: function(){
      clearInterval(this.timer);
    },
    handleChange: function() {
      this.setState({ text: document.getElementById('math-input').value });
      MathPreview.Update();
    },
    handleKeyDown: function(event) {
      if (event.ctrlKey) {
        if (event.keyCode == 10 || event.keyCode == 13) {
          this.checkExpr();
        } else if (event.keyCode == 66) {
          event.preventDefault();
          var elt = $('#math-input');
          // Voir aussi dans editeurs/scite/malg_abbrev.properties.
          var abbrevs = {
            "(s":  "(somme |)",
            "(d":  "(diff |)",
            "(o":  "(oppose |)",
            "(p":  "(produit |)",
            "(p.": "(produit. |)",
            "(q":  "(quotient |)",
            "(i":  "(inverse |)",
            "(ca": "(carre |)",
            "(r2": "(racine2 |)",
            "(r":  "(racine |)",
            "(ca": "(cube |)",
            "(pu": "(puissance |)",
            "(in": "(indice |)",
            "(im": "(imagepar |)"
          };
          // Grab content and split in 'before' and 'after' caret.
          var src = elt.val();
          var current_pos = elt.getCursorPosition();
          var before = src.substring(0, current_pos);
          var after = src.substring(current_pos, src.length);
          // Detect a possible abbreviation: look for the previous '('.
          var last_paren_pos = before.lastIndexOf("(");
          if (last_paren_pos >= 0) {
            var key = before.substring(last_paren_pos, before.length);
            var abbrev = abbrevs[key];
            if (typeof abbrev != 'undefined') {
              var before_wo_abbrev = before.substring(0, before.length - key.length);
              elt.val(before_wo_abbrev + abbrev.replace("|", "") + after);
              // Restore caret position, according to abbrev.
              var pos = elt.val().length + abbrev.lastIndexOf("|") + 1 - abbrev.length - after.length;
              elt.selectRange(pos, pos);
            }
          }
          this.handleChange();
        }
      }
    },
    checkExpr: function() {
      if (!this.state.running) return;
      var expected_input = this.state.series.exprs[this.state.expr_id].expr;
      var normalized_input =
          this.state.text.replace(/[\n ]+/g, ' ')  // singlify whitespace
                         .replace('( ', '(')       // if whitespace after paren
                         .replace(' )', ')')       // if whitespace before paren
      console.log('expected:   ' + expected_input);
      console.log('normalized: ' + normalized_input);
      if (normalized_input === expected_input) {
        var new_score = this.state.score + this.inSeriesGet('points');
        this.setState({
          text: '',
          score: new_score});
        $('#math-preview').text('');
        $('#math-buffer').text('');
        $('#math-input').val('');
        $('#math-input').keyup();
        this.state.series.exprs[this.state.expr_id].date_end = Date.now();
        this.state.series.exprs[this.state.expr_id].score_end = new_score;
        var it_was_the_last = (this.state.expr_id == this.state.series.exprs.length - 1);
        if (it_was_the_last) {
          this.setState({running: false});
          clearInterval(this.timer);
        } else {
          this.setState({expr_id: this.state.expr_id + 1});
          this.state.series.exprs[this.state.expr_id+1].date_start = Date.now();
          this.state.series.exprs[this.state.expr_id+1].score_start = new_score;
        }
      } else {
        alert("Essaie encore !");
      }
    },
    handleRapport: function() {
      this.setState({rapport: !this.state.rapport});
    },
    tick: function() {
        this.setState({score: this.state.score - 1});
    },
    render: function() {
      return (
        <div className="well clearfix">
          <h1>{this.state.series.title}</h1>
          <p>{this.intro()}</p>
          <div id="score" className="pull-right">{this.state.score} points</div>
          <div id="target"
               dangerouslySetInnerHTML={{__html: this.mathjax_src()}}/>
          <div id="math">
            <span id="math-preview"></span>
            <span id="math-buffer"></span>
          </div>
          <span>
            {!this.state.running ?
              "Voilà, c’est fini." :
              this.state.text.length > 0 ?
                " " :
                "Tapez vos commandes ci-dessous, puis validez avec OK ou Ctrl+Enter."
            }
          </span>
          <div id="lisp-error"></div>
          <textarea className="form-control" id="math-input"
                    onChange={this.handleChange}
                    onKeyDown={this.handleKeyDown}></textarea>
          <br/>
          <button className="btn btn-primary pull-right"
                  disabled={!this.state.running || this.state.text.length === 0}
                  onClick={this.checkExpr}>OK</button>
          {this.infos()}
          <p><a onClick={this.handleRapport}>{this.state.rapport? "fermer le rapport":"rapport"}</a></p>
          {this.rapport()}
        </div>
      );
    },
    intro: function() {
      if (this.state.series_id == 'default') {
        return <div>
                 <p>Tentez de reconstituer des expressions en tapant des
                 commandes. Quelques exemples :</p>
                 <ul>
                   <li>pour $2+2$, il faut taper <code>(somme 2 2)</code> ;</li>
                   <li>pour $2×x+1$, il faut taper <code>(somme (produit 2 x) 1)</code> ;</li>
                   <li>pour $2×\left(x+1\right)$, il faut taper <code>(produit 2 (p (somme x 1)))</code>.</li>
                 </ul>
                 <p>Voici l’expression à reconstituer :</p>
               </div>;
      }
    },
    infos: function() {
      if (this.state.running) {
        var s = this.inSeriesGet('points') > 1;
        return <p>Vous jouez pour {this.inSeriesGet('points')} point{s ? "s" : ""}.
               Vous perdez un point toutes
               les{this.inSeriesGet('point_duration')>1?" "+this.inSeriesGet('point_duration'):""} secondes.</p>
      }
    },
    rapport: function() {
      if (!this.state.rapport) return;
      return <div id="report">
        <h1>Rapport</h1>
        <p>{this.state.series.title} 
           (<a href="{window.location.toString()}">{window.location.toString()}</a>)</p>
        <p>Score : {this.state.score}</p>
        <ol>{
          this.state.series.exprs.map(function(elt, index) {
            return <li>{elt.expr} : 
             {elt.date_end? <span>{elt.score_end - elt.score_start} pts
                            en {(elt.date_end - elt.date_start)/1000 | 0}s</span>:"en cours…"}</li>;
          })
        }</ol>
        </div>;
    },
    lisp2latex: function(src) {
      var latex = ''
      try {
        latex = EMULISP_CORE.eval(src).toString();
      } catch(e) {
        latex = "Error with lisp source: " + src;
      }
      // Do not display NIL.
      if (latex == "NIL") latex = "";
      // If surrounded with ", remove these.
      if (latex.match(/^".*"$/)) latex = latex.slice(1, -1);
      // Work around PicoLisp transients.
      latex = latex.replace(/\\\\/g, "\\");
      latex = latex.replace(/\\\^/g, "^");
      return latex;
    },
    mathjax_src: function() {
      return"$$" + this.lisp2latex(this.inSeriesGet('expr')) + " $$"
    }
  });
  React.render(
    <InterExpr />,
    document.getElementById('jsx')
  );
  MathPreview.Init("math-input", "math-preview", "math-buffer", "lisp-error");
  createRichInput("#math-input");
  $("#math-input").focus();
  var cmds_list = EMULISP_CORE.eval('cmds_list').toString();
  var cmds = cmds_list.slice(1, -1).split(' ');
  $("#cmds-list").text(cmds.join(", "));
  </script>
</body>
</html>
